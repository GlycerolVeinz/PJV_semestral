package goblinoverflow.logic.movement.pathfinding;

import goblinoverflow.Simulation;
import goblinoverflow.entities.tiles.Tile;

import java.util.ArrayList;

public class AStar {
	private final ArrayList<Tile> openList;
	private final ArrayList<Tile> closedList;
	private final Tile start;
	private final Tile end;

	public AStar(Tile start, Tile end) {
		this.openList = new ArrayList<>();
		this.closedList = new ArrayList<>();
		this.start = start;
		this.end = end;
	}

	public Tile findPath(boolean doors) {
//		most of this method was generated by GitHub Copilot
		openList.add(start);
		while (!openList.isEmpty()) {
			Tile current = openList.get(0);
			for (Tile tile : openList) {
				if (tile.getF() < current.getF()) {
					current = tile;
				}
			}
			openList.remove(current);
			closedList.add(current);
			if (current == end) {
				return reconstructPath(current);
			}
			for (Tile neighbor : Simulation.getGameMap().getNeighbours(current)) {
				if (!doors && neighbor.getName().equals("door")) {
					continue;
				}
				if (neighbor.getName().equals("wall") || closedList.contains(neighbor)) {
					continue;
				}
				int tentativeG = current.getG() + 1;
				if (!openList.contains(neighbor) || tentativeG < neighbor.getG()) {
					neighbor.setG(tentativeG);
					neighbor.setH(neighbor.getDistance(end));
					neighbor.setF(neighbor.getG() + neighbor.getH());
					if ((neighbor.getX() == current.getX()) && (neighbor.getY() == current.getY())) {
						System.err.println("something is wrong");
						System.err.println("current: " + current.getX() + ", " + current.getY());
						System.err.println("neighbor: " + neighbor.getX() + ", " + neighbor.getY());
					}
					neighbor.setParent(current);
					if (!openList.contains(neighbor)) {
						openList.add(neighbor);
					}
				}
			}
		}

		return null;
	}

	public Tile getStart() {
		return start;
	}

	public Tile reconstructPath(Tile current) {
		while (current.getParent() != getStart() || current.getParent().getCoord() == current.getCoord()) {
			current = current.getParent();
		}
		return current;
	}

}
