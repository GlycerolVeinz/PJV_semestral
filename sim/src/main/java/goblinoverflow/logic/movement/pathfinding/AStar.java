package goblinoverflow.logic.movement.pathfinding;

import goblinoverflow.Simulation;
import goblinoverflow.entities.tiles.Tile;

import java.util.ArrayList;

/**
 * A* inspired pathfinding algorithm.
 * Finds a path between two tiles.
 */
public class AStar {
	private final ArrayList<Tile> openList;
	private final ArrayList<Tile> closedList;
	private final Tile start;
	private final Tile end;

	/**
	 * Constructor for AStar class.
	 * @param start starting tile.
	 * @param end final tile (target).
	 */
	public AStar(Tile start, Tile end) {
		this.openList = new ArrayList<>();
		this.closedList = new ArrayList<>();
		this.start = start;
		this.end = end;
	}

	public Tile getStart() {
		return start;
	}

	/**
	 * Reconstructs the path from the current Tile to the start.
	 * @param current current Tile that we want to get to.
	 * @return Tile that you should move to next.
	 * */
	public Tile reconstructPath(Tile current) {
		while (current.getParent() != getStart() || current.getParent().getCoord() == current.getCoord()) {
			current = current.getParent();
		}
		return current;
	}

	/**
	 * Finds a path between two tiles.
	 * @param doors if true, path can go through doors.
	 * @return Tile that is the next step in the path:
	 * 				<p>- if the path is empty, returns null.</p>
	 */
	public Tile findPath(boolean doors) {
//		most of this method was generated by GitHub Copilot
		openList.add(start);
		while (!openList.isEmpty()) {
			Tile current = openList.get(0);
			for (Tile tile : openList) {
				if (tile.getF() < current.getF()) {
					current = tile;
				}
			}
			openList.remove(current);
			closedList.add(current);

			if (current == end) {
				return reconstructPath(current);
			}

			for (Tile neighbor : Simulation.getGameMap().getNeighbours(current)) {
				if (!doors && neighbor.getName().equals("door")) {
					continue;
				}

				if (neighbor.getName().equals("wall") || closedList.contains(neighbor)) {
					continue;
				}

				int tentativeG = current.getG() + 1;
				if (!openList.contains(neighbor) || tentativeG < neighbor.getG()) {
					neighbor.setG(tentativeG);
					neighbor.setH(neighbor.getDistance(end));
					neighbor.setF(neighbor.getG() + neighbor.getH());
					if ((neighbor.getX() == current.getX()) && (neighbor.getY() == current.getY())) {
						System.err.println("Something is wrong with neighbors.");
						System.err.println("current: " + current.getX() + ", " + current.getY());
						System.err.println("neighbor: " + neighbor.getX() + ", " + neighbor.getY());
					}
					neighbor.setParent(current);
					if (!openList.contains(neighbor)) {
						openList.add(neighbor);
					}
				}
			}
		}
		return null;
	}
}
